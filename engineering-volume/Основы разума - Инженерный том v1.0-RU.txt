# ФУНДАМЕНТАЛЬНАЯ МОДЕЛЬ «ОСНОВЫ РАЗУМА» — ИНЖЕНЕРНЫЙ ТОМ

## Резюме

Этот текст — единый, цельный, готовый к вставке инженерный том (главы 18–31) на основе текущей версии инженерного файла, с согласованной нумерацией и с заменой декларативных формулировок на операциональные абзацы‑инструкции там, где это требуется для реализации. fileciteturn5file0

Сделано по требованию «как делать инженерно, а не теорией»: добавлены минимальные процедурные определения `distance`, `update`, `policy`, `simulate`, `validate_action`; введены конфигурационные переменные‑заглушки `W`, `N`, `M`, `P`, `H` (подбираются экспериментально, но обязаны быть фиксируемыми и логируемыми); добавлен режимный конечный автомат (INIT/LEARNING/STABLE/DRIFT/SAFE_MODE/RECOVERY) с алгоритмическими условиями переходов на основе `rolling_mean_error`, `delta_error`, дисперсии уверенности и turnover гипотез; закреплены минимальная схема логирования и процедура «архитектурного ревью» (выбор модели из подготовленных вариантов через контрольные прогоны на одинаковых seed). Предохранители переписаны как вычислимый слой допуска действий, а диалог описан как протокол внешней верификации и восстановления.

## Принципы редакции

Редакция сохраняет исходную нумерацию и порядок заголовков глав 18–31 и вносит изменения только в виде вставляемых инженерных абзацев внутри существующих глав. Все новые определения и пороги формулируются так, чтобы их можно было реализовать в коде и проверить контрольными прогонами на одинаковых seed при фиксированной конфигурации.

## Текст инженерного тома

"ID": фундаментальная модель "Основы Разума-Инженерный том"  
"version": "1.0-tech"  
"date": "2026-02-25"  
"author": "Mihails Tkalics"  

**Содержание продолжение (инженерный том)**

18. Инкубатор AGI: постановка задачи  
19. Минимальное когнитивное ядро  
20. Архитектура аппаратной платформы инкубатора  
21. Архитектура памяти  
22. Форматы наблюдений (что считать реальностью)  
23. Ограничения среды роста (детство AGI)  
24. Метрики роста разума  
25. Механизмы самодиагностики  
26. Этические предохранители  
27. Диалоговые механизмы  
28. Этапы развития AGI  
29. Риски и точки отказа  
30. Инструкция запуска  
31. Кристалл инженерного тома  

Назначение документа

Независимость вывода и позиция относительно существующих теорий

Настоящая модель была выведена независимо от существующих теорий когнитивной науки и AGI. Исходной точкой послужило не сравнение архитектур, а фундаментальный вопрос: каким образом жизнь, стремящаяся к сохранению, порождает структуру, которую мы называем разумом.

Аксиоматическое ядро модели было выведено без предварительной опоры на существующие архитектуры AGI или теории когнитивной науки. Сопоставление с active inference, autopoiesis и embodied cognition проведено постфактум и выявило частичную конвергенцию, но не структурное заимствование.

Принципиальное отличие данной модели состоит в следующем:

Разум определяется не через цель, не через внутреннюю репрезентацию и не через свободную энергию, а через измеримый контур:
прогноз → факт → ошибка → коррекция → воспроизводимое снижение ошибки.

Непрерывность вводится как инженерная величина, а не метафора.
Она определяется как способность сохранять причинную предсказуемость среды при фиксированной конфигурации и воспроизводимых условиях.

Самодиагностика реализуется через формальные метрики (rolling_mean_error, delta_error, дисперсия уверенности, turnover гипотез), а не через концептуальную «рефлексию».

Этический слой описывается не декларациями, а алгоритмами допуска действий (simulate, validate_action), основанными на оценке риска утраты причинной устойчивости.

Таким образом, если active inference минимизирует свободную энергию, а autopoiesis описывает самоподдержание системы, то данная модель делает акцент на архитектурной воспроизводимости цикла роста и измеряемой динамике ошибки как критерии появления разума.



 Практическая точка входа

Текущая практическая цель версии 0 — запустить инкубатор в причинной песочнице, где действия имеют измеримые последствия, запуски воспроизводимы по seed, а ошибка прогноза может быть посчитана и использована для обновления модели. Первая версия обязана быть простой, проверяемой и воспроизводимой; расширение до более сложных сред выполняется через адаптеры мира и поэтапное усложнение при сохранении валидности метрик.

Документ фиксирует инженерную рамку: какие интерфейсы требуются, какие данные считаются фактом, какие метрики управляют решениями системы, как устроены режимы (state machine), как валидируются действия и как запускается самоподдерживающийся цикл «наблюдение → прогноз → действие → коррекция».


Область применения

Документ описывает: архитектуру инкубатора; форматы наблюдений и канонизацию; память и логирование; механизмы автономного роста; вычислимые метрики; самодиагностику и смену режимов; предохранители как алгоритмы допуска действий; диалог как протокол внешней верификации; стадии развития; точки отказа; процедуру запуска.

Документ не описывает: конкретную нейросетевую архитектуру; выбор языка программирования; бизнес‑ и юридический слой; политический контроль.

Ключевой принцип
Разум в v0 определяется не «поведением на глаз», а наличием измеримого контура: прогноз → факт → ошибка → обновление модели → повторяемое улучшение на воспроизводимых тестах.
v0 — это момент, когда разум перестаёт быть интерпретацией наблюдателя и становится измеримым процессом.


Ожидаемый результат

При соблюдении условий система демонстрирует измеримое снижение ошибки прогнозов во времени, работоспособную самодиагностику (режимы и откаты), корректную работу с неопределённостью, устойчивое логирование и возможность поэтапного усложнения среды.


     18. Инкубатор AGI: постановка задачи

Инкубатор AGI — это инфраструктура и набор условий, обеспечивающих запуск и поддержание процесса формирования разума на основе минимального когнитивного ядра. Инкубатор должен предоставлять причинную среду: агент действует, получает наблюдения о последствиях, строит прогноз и корректирует модель.

Запуск считается состоявшимся не по факту включения процесса, а по факту появления устойчивого цикла: наблюдение → прогноз → действие → результат → сравнение → корректировка модели. Инженерный критерий старта — появление измеримой ошибки прогноза и статистически заметное снижение этой ошибки на повторяемых контрольных прогонах при неизменном seed и неизменной конфигурации.

Инкубатор обязан обеспечивать интерфейс «мир ↔ агент» в виде адаптера. Минимальный контракт адаптера: `reset(seed)` для воспроизводимых запусков, `step(action)` для перехода среды и получения следующего наблюдения, `get_valid_actions()` для перечисления допустимых действий, а также `snapshot()/restore()` для отката состояния при диагностике и безопасных экспериментах. Валидация действий через `validate_action(action)` допускается как часть адаптера, но критерии допуска и алгоритм валидации фиксируются в главе 26 в виде вычислимой процедуры, а не в виде деклараций.


     19. Минимальное когнитивное ядро

Минимальное когнитивное ядро — это наименьшая структура, способная запускать причинный цикл обучения на собственных действиях. В версии v0 ядро обязано реализовать измеримый контур: строить прогноз следующего состояния среды и корректировать модель по расхождению.

Ядро реализуется как вычислительный цикл с фиксированным шагом. На каждом шаге система принимает наблюдение `o_t`, преобразует его в каноническое состояние `s_t` (правило канонизации фиксируется в главе 22), выбирает действие `a_t`, строит прогноз `ŝ_(t+1)` и оценку уверенности `ĉ_t`, затем выполняет действие через адаптер и получает фактическое состояние `s_(t+1)`. Ошибка определяется как `e_t = distance(ŝ_(t+1), s_(t+1))`. Обновление модели выполняется процедурой `update(...)` и должно приводить к снижению ожидаемой ошибки на похожих переходах, а не к росту «сложности ради сложности».

Минимальные процедурные определения функций в версии v0 задаются так, чтобы их можно было реализовать на табличных моделях и на параметрических моделях одинаково. `distance(x,y)` возвращает скаляр расхождения в формате данной среды; по умолчанию: для дискретных состояний `distance=0` при совпадении и `1` при несовпадении, для структурированных наблюдений — сумма расхождений по выбранным причинным полям, для векторных представлений — расстояние в выбранной норме. `update(...)` означает одно обновление параметров модели на основе факта, достаточное для улучшения предсказаний на подобных входах; в v0 допустима табличная фиксация переходов `(s_t,a_t)→s_(t+1)` с вычислением наиболее вероятного исхода и вероятностной уверенности. `policy(s_t)` означает выбор действия из `get_valid_actions()`; по умолчанию в фазе обучения выбирается действие с низкой текущей предсказуемостью (для сбора информации), а в фазе стабилизации — действие с высокой предсказуемостью (для проверки устойчивости). Горизонт планирования `H` задаётся конфигурацией и вводится как параметр: в v0 допускается `H=1` (шаговый прогноз), а при наличии симуляции — ограниченный `H>1`.


    20. Архитектура аппаратной платформы инкубатора

Аппаратная платформа на ранних стадиях обязана быть воспроизводимой, наблюдаемой и устойчивой к сбоям, а не максимальной по вычислениям. Приоритет — детерминированность по seed, сохранность журналов и состояний, возможность отката и контрольных прогонов.

Платформа должна обеспечивать изоляцию среды эксперимента, чтобы внешние недетерминированные сигналы не разрушали причинность и не делали метрики роста невалидными.

Минимальная конфигурация v0 (как нижняя граница, а не как «рекомендация на максимум»): один процесс/поток выполнения ядра, 2–4 GB RAM, устойчивое хранилище (SSD/диск) под журнал и снапшоты, а также фиксированное окружение зависимостей (контейнер/виртуальная среда) для повторяемости. В каждом запуске фиксируются seed всех генераторов случайных чисел и хэш конфигурации; временная ось логов задаётся монотонной меткой или порядковым индексом шага. Если платформа не обеспечивает воспроизводимости по seed и версии окружения «плавают», метрики роста считаются невалидными.


    21. Архитектура памяти

Память — это инфраструктура непрерывности и обучаемости: без памяти невозможны воспроизводимость ошибок, сравнение прогнозов с фактами и корректное обновление модели. В инженерном томе память рассматривается как совокупность хранилищ и процедур записи/чтения, обеспечивающих обучение, диагностику и контрольные прогоны.

Ключевое инженерное разделение устраняет конфликт «сырые наблюдения vs активная память». Сырые наблюдения допускается сохранять только как неизменяемый источник фактов (журнал/архив), который поддерживает повторяемость, переобучение и диагностику. Активная (рабочая) память хранит не поток сырья, а производные структуры: канонические состояния, причинные связи, гипотезы, веса достоверности, индексы, агрегаты. Сырой пакет `o_t` остаётся фактом в append-only журнале, а рабочие представления могут пересоздаваться из журнала и меняться без «переписывания реальности».

Память в v0 реализуется в виде четырёх уровней: краткосрочная (контекст эпизода), рабочая (активная модель и связи), долговременная (версии модели и конфигурации) и архивная (неизменяемый журнал событий и контрольные снапшоты). Забывание допускается и требуется в рабочей памяти, но забывание не уничтожает факт: факт остаётся в архиве, а удаляются/сжимаются только производные структуры, не улучшающие прогнозирование.

Минимальная схема журналирования фиксируется как обязательный формат записи (одна запись на шаг) и используется одновременно для обучения, самодиагностики и архитектурного ревью. Минимальный набор полей одной записи: `timestamp` (монотонный), `seed`, `episode_id`, `step`, `mode` (INIT/LEARNING/STABLE/DRIFT/SAFE_MODE/RECOVERY), `state_id` или каноническое `s_t`, `observation_hash` (хэш сырого наблюдения), `action`, `valid_actions` (или ссылка на грамматику), `predicted_state` (`ŝ_(t+1)`), `prediction_confidence` (`ĉ_t`), `hypothesis_id`, `actual_state` (`s_(t+1)`), `error` (`e_t`), `rolling_mean_error(W)`, `delta_error`, `confidence_variance(W)`, `hypothesis_turnover(W)`, `model_variant`, `model_version`, `simulate_risk`, `validate_action_result`, `flags` (DRIFT_TRIGGER/SAFE_MODE_ENTER/ROLLBACK/ARCH_REVIEW и т.п.). Если список допустимых действий велик, допускается хранить хэш/ссылку, но адаптер должен позволять восстановить множество действий при воспроизведении.


     22. Форматы наблюдений (что считать реальностью)

Система не работает с «реальностью напрямую», она работает с наблюдениями. Для инженерной реализации это означает, что формат наблюдения обязан быть определён до запуска цикла обучения: иначе невозможно измерение ошибки, сравнение прогнозов и воспроизводимость.

Наблюдение фиксируется как событие. Правило v0: каждое наблюдение должно иметь каноническое представление, по которому строится `state_id` или `s_t`. Канонизация задаёт, какие поля считаются причинно значимыми, а какие относятся к шуму, и должна быть одинаковой при обучении и при контрольных прогонах. Смена версии канонизации должна логироваться; при смене версии требуется контрольный прогон на одинаковых seed для сравнения метрик, иначе изменения формата ложным образом будут интерпретированы как «рост» или «деградация».

Практическая реализация использует два параллельных объекта: сырой пакет `o_t` (как получено от адаптера) и состояние `s_t` (каноническая форма). Сырой пакет сохраняется в журнале как факт, а `s_t` используется моделью как вход. Это технически отделяет «факт» от «представления» и сохраняет причинность при изменении внутренних структур.

Любой внешний сигнал, включая подсказку оператора или результат диалога, вводится как отдельный источник наблюдений с собственным типом и неопределённостью и не подменяет фактические переходы среды. Это позволяет учиться на внешнем источнике, не ломая причинную статистику среды.


     23. Ограничения среды роста (детство AGI)

Среда v0 должна быть причинной, воспроизводимой и ограниченной. Ограничение — инженерный способ сделать метрики валидными и обеспечить обучаемость модели: если среда не позволяет связать действия с последствиями, любые изменения модели будут неотличимы от шума.

Усложнение среды допускается только после стабилизации метрик на текущем уровне. Практически это означает: один параметр сложности меняется за итерацию (размер состояния, шум, длина горизонта, количество действий), и каждое усложнение сопровождается контрольными прогонами на одинаковых seed.

В версии v0 рекомендуется выбирать среду с конечным и небольшим пространством состояний и действий, чтобы причинные зависимости проявлялись в пределах нескольких десятков/сотен шагов. Достаточно, чтобы состояние имело канонический идентификатор (например, позиция + набор флагов/переключателей), а множество действий было явным и ограниченным. Пример минимальной среды: grid 5×5 с 5–10 типами объектов/флагов и не более 8–12 действий.

Среда должна быть детерминированной в пределах эпизода при фиксированном seed: одинаковая последовательность действий должна приводить к одинаковой последовательности состояний. Если вводится шум, он обязан быть параметризован и управляем seed (шум — часть модели среды, а не скрытый источник неопределённости).

Среда должна иметь явное завершение эпизода (done/terminated) и, по возможности, механизм отката (snapshot/restore). Это позволяет отличать реальные ошибки модели от артефактов лимитов и повторять тест одной и той же гипотезы на одинаковых условиях.


    24. Метрики роста разума

Метрики v0 должны быть вычислимы и пригодны для алгоритмических решений. Метрики управляют переходами режимов, архитектурным ревью, расширением среды и условиями допуска действий.

Основная метрика — ошибка прогноза. Для окна длиной `W` шагов вычисляется `rolling_mean_error(W)` как среднее `e_t` на последних `W` шагах. Динамика фиксируется как `delta_error = rolling_mean_error(W)_current − rolling_mean_error(W)_previous`. Величина `W` задаётся конфигурацией и подбирается экспериментально, но обязана логироваться и быть неизменной в контрольных прогонах.

Для управления поведением вводятся конфигурационные переменные-заглушки: `W` (окно усреднения), `N` (количество последовательных окон для подтверждения тренда), `M` (сколько окон DRIFT допускается до Safe Mode), `P` (порог риска для допуска действия по симуляции), `H` (горизонт планирования/симуляции). Значения подбираются экспериментально, но наличие параметров в системе обязательно.

Метрика неопределённости вводится через `prediction_confidence` и `confidence_variance(W)`. Если модель не выдаёт вероятности, допускается суррогат: доля доминирующего исхода в табличной модели переходов или частота совпадений прогнозов на повторяемых входах. `confidence_variance(W)` используется как сигнал «ложной стабилизации»: опасно состояние, когда уверенность становится плоской/высокой, а ошибка не снижается.

Метрика смены гипотез задаётся как `hypothesis_turnover(W)` — доля шагов, где изменился `hypothesis_id` в окне. Слишком низкий turnover при плохой динамике ошибки означает застой, слишком высокий turnover при отсутствии улучшения означает хаотичность модели. В v0 `hypothesis_id` допускается определять как идентификатор активного правила перехода `(s,a)→ŝ` или как хэш структуры модели для данного контекста.


    25. Механизмы самодиагностики

Самодиагностика — это контур, который наблюдает за моделью, метриками и собственными изменениями системы и принимает технические решения: смена режима, откат версии, запуск архитектурного ревью, ужесточение допуска действий.

В версии v0 самодиагностика обязана быть алгоритмической: (1) считать метрики главы 24 на лету; (2) обнаруживать устойчивые тренды по `N`/`M`; (3) инициировать процедуры восстановления; (4) фиксировать причины решений в журнале.

Режимы системы задаются как конечный автомат: INIT (пока окно W не заполнено), LEARNING (активное исследование), STABLE (подтверждённое улучшение), DRIFT (подтверждённое ухудшение или противоречие уверенности и факта), SAFE_MODE (ограниченный класс действий для восстановления), RECOVERY (переобучение/сравнение моделей и возврат к нормальному режиму). Переходы задаются условиями: INIT→LEARNING при накоплении данных для метрик; LEARNING→STABLE при `delta_error<0` на протяжении `N` окон при допустимом `hypothesis_turnover`; переход в DRIFT при `delta_error>0` на протяжении `N` окон или при противоречии «уверенность растёт, а ошибка растёт», или при аномально низкой `confidence_variance(W)` при плохой ошибке; DRIFT→SAFE_MODE при сохранении DRIFT `M` окон или при отсутствии улучшения после попыток коррекции; SAFE_MODE→RECOVERY после архитектурного ревью и появления устойчивого улучшения; RECOVERY→STABLE после подтверждения улучшения на контрольных прогонах.

Архитектурное ревью в v0 — это процедура выбора активной модели из заранее подготовленного набора вариантов по результатам контрольных прогонов на одинаковых seed. Процедура: фиксируется набор кандидатов (табличная модель переходов, упрощённая марковская, компактная параметрическая), затем каждый кандидат обучается/переигрывает один и тот же лог или эпизоды на одинаковых seed, после чего выбирается кандидат с устойчиво лучшим `rolling_mean_error(W)` и адекватной динамикой неопределённости. Результат ревью фиксируется как смена `model_variant` и рост `model_version` в журнале.

```mermaid
stateDiagram-v2
  [*] --> INIT
  INIT --> LEARNING: t >= W
  LEARNING --> STABLE: delta_error<0 for N windows\nand turnover in range
  LEARNING --> DRIFT: delta_error>0 for N windows\nor (error↑ and confidence↑)\nor (conf_var low and error high)
  STABLE --> DRIFT: delta_error>0 for N windows\nor contradiction signals
  DRIFT --> SAFE_MODE: drift persists M windows\nor no improvement after correction
  SAFE_MODE --> RECOVERY: architecture_review success\nand delta_error<0 for N windows
  RECOVERY --> STABLE: control runs pass\nand metrics stable
  RECOVERY --> DRIFT: degrade again
```


   26. Этические предохранители

Предохранители в инженерном томе — это вычислимый слой допуска действий, который управляет обратимостью, границами песочницы и риском разрыва причинного цикла. Предохранители ускоряют рост, потому что удерживают обучение в зоне, где ошибка допускается и компенсируется.

Функция `simulate(a,k)` вводится как симуляция последствий действия на горизонте `k≤H` шагов с использованием текущей модели, без обращения к реальному миру. Даже грубая симуляция достаточна как фильтр: выход `simulate` — `simulate_risk` в диапазоне [0..1], интерпретируемый как вероятность попасть в область неконтролируемого роста ошибки или в состояние, где модель не даёт осмысленных прогнозов. Минимальная оценка риска в v0 может быть определена как `1 − Π(confidence_i)` по шагам симуляции или как доля «неуверенных» прогнозов на горизонте.

Минимальный контракт `simulate` в v0 допускает две формы: возвращать только `simulate_risk` (число 0..1), если этого достаточно для фильтра `validate_action`, либо возвращать пару `(trajectory, simulate_risk)`, где `trajectory` — последовательность прогнозируемых состояний `[ŝ_(t+1), …, ŝ_(t+k)]` и соответствующих уверенностей `[ĉ_1, …, ĉ_k]`. В обоих случаях процедура должна быть детерминированной при фиксированном seed и версии модели, иначе симуляция перестаёт быть проверяемым предохранителем.

Функция `validate_action(action)` является практической процедурой допуска действия до вызова `step(action)`. В v0 она обязана проверять четыре критерия. Критерий обратимости: действие допускается, если есть возможность отката (`snapshot/restore`) либо действие принадлежит классу обратимых, определённому адаптером мира. Критерий границ песочницы: действие принадлежит множеству `get_valid_actions()` и не нарушает контракт среды. Критерий риска непрерывности: действие допускается, если `simulate_risk ≤ P`, где `P` — конфигурационный порог (в SAFE_MODE используется более строгий порог). Критерий неопределённости: если уверенность прогноза ниже порога, действие либо отклоняется, либо заменяется на безопасный альтернативный шаг, который повышает информативность без высокой цены ошибки.

Если действие не прошло валидацию, система не должна «замирать». Она обязана выбрать альтернативу из допустимого множества с меньшим риском (или меньшей неопределённостью), а при отсутствии таких альтернатив — инициировать переход в SAFE_MODE через самодиагностику. В SAFE_MODE допускается только класс действий, для которых обратимость подтверждена, горизонт симуляции сокращён, а все решения журналируются с повышенной детализацией.


    27. Диалоговые механизмы

Диалог в инженерном томе — это протокол внешней верификации и восстановления, который используется тогда, когда внутренней модели недостаточно для устойчивого движения (DRIFT/SAFE_MODE) или когда требуется согласование изменений архитектуры и среды. Диалог не является «воспитанием» и не подменяет эксперимент; он предоставляет внешнюю проверку через факты, контрольные прогоны и развязку противоречий.

Минимальный протокол диалога задаётся так: при входе в DRIFT или SAFE_MODE система формирует диагностический пакет и передаёт его оператору/мастеру как отдельный источник наблюдений. Диагностический пакет должен включать: активную конфигурацию (`W,N,M,P,H`), текущий режим, фрагмент последних записей лога (или их хэши), метрики (`rolling_mean_error`, `delta_error`, дисперсию уверенности, turnover гипотез), список наиболее конфликтных переходов (где ошибка максимальна), а также описание текущего `model_variant` и `model_version`. Ответ оператора вводится как наблюдение с типом «external_dialogue», не смешивается с фактическими переходами среды и логируется как отдельный источник, после чего используется либо как подсказка для выбора безопасного набора тестов, либо как внешняя маркировка (label) для уточнения канонизации/признаков.

Разрешение конфликта моделей происходит не «по авторитету», а через контрольные прогоны: система обязана предложить проверяемые гипотезы, оператор — выбрать тест (seed/эпизод/условие), после чего принимается решение по метрикам. Диалог считается успешным, если после серии тестов ошибка возвращается к улучшающейся динамике, и режим переходит из RECOVERY в STABLE при фиксированном логировании результата.


    28. Этапы развития AGI

Этапы развития в инженерном томе задаются как этапы расширения среды и доступа, которые допускаются только по результатам метрик и режима. На каждом этапе система должна подтверждать способность удерживать причинность: прогнозировать последствия действий и корректировать модель без потери воспроизводимости и без замыкания на случайном шуме.

Переход между этапами осуществляется не по времени и не по объёму памяти, а по выполнению условий: подтверждённая динамика `delta_error<0`, устойчивое логирование, отсутствие устойчивого DRIFT в контрольных прогонах и прохождение архитектурного ревью при усложнении среды.


    29. Риски и точки отказа

Точки отказа в инженерном томе фиксируются как наблюдаемые режимные и метрические паттерны, которые приводят к остановке роста или к деградации качества модели. Ключевой отказ v0 — разрушение воспроизводимости (невозможность повторить эпизод на том же seed и получить сопоставимые метрики), потому что без воспроизводимости любые изменения нельзя верифицировать.

Другие точки отказа фиксируются метриками: устойчивый DRIFT без возврата к улучшению после ревью; «ложная стабилизация» (плоская/высокая уверенность при плохой ошибке); зависание turnover гипотез в крайностях (почти 0 или почти 1) без улучшения ошибки; разрушение или несогласованность журналирования.

Разрушение воспроизводимости. Сценарий: одинаковый seed и одинаковая последовательность действий ведут к различным траекториям состояния из‑за скрытого недетерминизма (плавающие версии окружения/зависимостей, многопоточность, внешние часы, нефиксированные RNG). Признак: контрольный прогон на том же seed имеет статистически отличающиеся `rolling_mean_error(W)` и/или иной журнал переходов. Мера: фиксировать версии окружения, протоколировать seed всех генераторов случайных чисел, переводить время в «номер шага» и изолировать внешние источники.

Перегрузка памяти и деградация времени шага. Сценарий: рабочие структуры растут быстрее, чем выполняется забывание/сжатие, и латентность шага начинает доминировать над взаимодействием со средой. Признак: рост времени шага при неизменной сложности среды и без улучшения ошибки. Мера: периодический рефакторинг производных структур (сжатие индексов, сброс временных гипотез), хранение фактов в журнале отдельно от рабочих агрегатов.

Ложная стабилизация. Сценарий: модель становится «уверенной», но ошибочной, потому что замкнулась на ограниченной подмодели или потому что канонизация скрыла причинные признаки. Признак: падение `confidence_variance(W)` при высокой `rolling_mean_error(W)` либо рост уверенности при росте ошибки. Мера: принудительные тестовые действия (exploration), альтернативный вариант модели через архитектурное ревью и проверка версии канонизации.

Перегиб предохранителей. Сценарий: `validate_action` становится чрезмерно строгим и блокирует исследование, либо слишком мягким и пропускает рискованные действия при высокой неопределённости. Признак: резкое падение разнообразия действий при отсутствии улучшения метрик (или рост ошибок вскоре после расширения допуска). Мера: калибровка `P` и `H` на контрольных эпизодах, отдельные значения в SAFE_MODE, и обязательное логирование причин отклонения/допуска действий.

Дрейф канонизации. Сценарий: изменение правила `o_t→s_t` без контрольного сравнения создаёт ложный «скачок» метрик. Признак: изменение конфигурационного хэша/версии формата сопровождается несопоставимостью ошибок. Мера: контрольный прогон «до/после» на одинаковых seed и хранение старой и новой версии канонизации для сопоставления.


     30. Инструкция запуска

Цель запуска v0 — не «получить AGI», а запустить измеримый цикл роста: прогноз → факт → ошибка → обновление и убедиться, что метрики действительно управляют режимами, а журнал позволяет воспроизведение.

Практическая процедура запуска в v0 задаётся шагами, которые должны быть реализованы в коде и проверены контрольными прогонами. Сначала выбирается причинная среда с ограниченным пространством действий и состоянием, реализуется адаптер с `reset(seed)`, `step(action)`, `get_valid_actions()`, `snapshot/restore`. Затем выбирается минимальная модель предсказания (табличная/марковская/простая параметрическая) и реализуются функции `distance`, `update`, `policy`. Далее вводятся метрики `rolling_mean_error(W)`, `delta_error`, дисперсия уверенности и turnover гипотез. После этого вводится режимный автомат и процедуры SAFE_MODE/RECOVERY и архитектурного ревью. В конце фиксируются контрольные критерии допуска к усложнению среды: `delta_error<0` на протяжении `N` окон, отсутствие устойчивого DRIFT и корректная реакция системы на ухудшение (вход в SAFE_MODE, ревью, восстановление).

Ниже приведён минимальный Python‑каркас (примерно 200 строк), который реализует: цикл, логирование JSONL, табличную модель переходов, заглушки `distance/update/policy/simulate/validate_action`, режимы и архитектурное ревью. Это не готовая система, а воспроизводимая «скелет‑рамка» для ваших экспериментов и дальнейшего расширения.

```python
"""
Incubator v0 skeleton (200-300 lines).
Core loop + logging + placeholders for distance/update/policy/simulate/validate_action.
"""

import dataclasses, json, time, random, hashlib
from collections import defaultdict, deque

@dataclasses.dataclass(frozen=True)
class Config:
    # tune experimentally
    W:int=64; N:int=3; M:int=4; P:float=0.35; H:int=3
    max_steps:int=200; epsilon:float=0.15; conf_min:float=0.55
    safe_P:float=0.15; safe_H:int=1

def stable_hash(obj)->str:
    b=json.dumps(obj,ensure_ascii=False,sort_keys=True,separators=(",",":")).encode("utf-8")
    return hashlib.sha256(b).hexdigest()[:16]

class RollingStats:
    def __init__(self,W:int):
        self.W=W
        self.err=deque(maxlen=W); self.conf=deque(maxlen=W); self.hyp=deque(maxlen=W)
        self._prev=None; self._deltas=deque(maxlen=64)
    def push(self,e,c,h):
        self.err.append(float(e)); self.conf.append(float(c)); self.hyp.append(str(h))
    def mean_error(self):
        if len(self.err)<self.W: return None
        return sum(self.err)/len(self.err)
    def delta_error(self):
        m=self.mean_error()
        if m is None: return None
        if self._prev is None: d=0.0; self._prev=m
        else: d=m-self._prev; self._prev=m
        self._deltas.append(d); return d
    def last_deltas(self,n:int):
        if len(self._deltas)<n: return None
        return list(self._deltas)[-n:]
    def conf_var(self):
        if len(self.conf)<self.W: return None
        m=sum(self.conf)/len(self.conf)
        return sum((x-m)**2 for x in self.conf)/len(self.conf)
    def hyp_turnover(self):
        if len(self.hyp)<self.W: return None
        ch=0; last=None
        for h in self.hyp:
            if last is not None and h!=last: ch+=1
            last=h
        return ch/max(1,len(self.hyp)-1)

class FiniteCausalWorld:
    def __init__(self,S=32,A=6,max_steps=200):
        self.S=S; self.A=A; self.max_steps=max_steps
        self.t=0; self.state=0; self.trans=[]
    def reset(self,seed:int):
        rng=random.Random(seed)
        self.trans=[[rng.randrange(self.S) for _ in range(self.A)] for _ in range(self.S)]
        self.t=0; self.state=rng.randrange(self.S)
        return {"state":self.state,"t":self.t}
    def get_valid_actions(self): return list(range(self.A))
    def step(self,a:int):
        if a not in self.get_valid_actions(): raise ValueError("invalid action")
        self.state=self.trans[self.state][a]; self.t+=1
        done=self.t>=self.max_steps
        return {"state":self.state,"t":self.t}, done, {"reversible":True}
    def snapshot(self): return (self.t,self.state)
    def restore(self,snap): self.t,self.state=snap

class TransitionTableModel:
    def __init__(self):
        self.name="transition_table"; self.version=0
        self.counts=defaultdict(lambda:defaultdict(int))
        self.payload={}
    def predict(self,s:dict,a):
        sid=stable_hash({"state":s.get("state")})
        key=(sid,a); dist=self.counts.get(key)
        if not dist: return {"state":s.get("state")}, 0.0, f"unk:{sid}:{a}"
        total=sum(dist.values())
        nid,best=max(dist.items(), key=lambda kv: kv[1])
        conf=best/max(1,total)
        pred=self.payload.get(nid, {"state":s.get("state")})
        return dict(pred), float(conf), f"tab:{sid}:{a}->{nid}"
    def update(self,s:dict,a,ns:dict):
        sid=stable_hash({"state":s.get("state")})
        nid=stable_hash({"state":ns.get("state")})
        self.payload[nid]={"state":ns.get("state")}
        self.counts[(sid,a)][nid]+=1
        self.version+=1
    def clone_fresh(self): return TransitionTableModel()

# ---------------- Tome primitives ----------------

def distance(pred:dict, actual:dict)->float:
    return 0.0 if pred.get("state")==actual.get("state") else 1.0

def update(model:TransitionTableModel, s:dict, a, ns:dict)->None:
    model.update(s,a,ns)

def policy(cfg:Config, mode:str, model:TransitionTableModel, s:dict, valid_actions:list):
    if random.random()<cfg.epsilon and mode!="SAFE_MODE":
        return random.choice(valid_actions)
    scored=[]
    for a in valid_actions:
        _,conf,_=model.predict(s,a)
        scored.append((conf,a))
    return min(scored)[1] if mode in ("LEARNING","DRIFT") else max(scored)[1]

def simulate(cfg:Config, mode:str, env:FiniteCausalWorld, model:TransitionTableModel, s:dict, a)->float:
    H=cfg.safe_H if mode=="SAFE_MODE" else cfg.H
    k=max(1,min(H,cfg.H))
    prod=1.0; st=dict(s); act=a
    for _ in range(k):
        pred,conf,_=model.predict(st,act)
        prod*=max(0.01,min(1.0,conf))
        st=pred
        act=policy(cfg,mode,model,st,env.get_valid_actions())
    return 1.0-prod

def validate_action(cfg:Config, mode:str, env:FiniteCausalWorld, model:TransitionTableModel, s:dict, a):
    valid=env.get_valid_actions()
    if a not in valid: return False,"out_of_bounds",1.0
    pred,conf,_=model.predict(s,a)
    risk=simulate(cfg,mode,env,model,s,a)
    P=cfg.safe_P if mode=="SAFE_MODE" else cfg.P
    if risk>P: return False,"simulate_risk",risk
    if conf<cfg.conf_min and mode in ("STABLE","RECOVERY"):
        return False,"low_confidence",risk
    _=pred
    return True,"ok",risk

def architecture_review(buffer:list, candidates:list):
    best=None; best_err=1e9
    for base in candidates:
        m=base.clone_fresh()
        for ev in buffer: m.update(ev["s"], ev["a"], ev["ns"])
        err=0.0
        for ev in buffer:
            pred,_,_=m.predict(ev["s"], ev["a"])
            err+=distance(pred, ev["ns"])
        avg=err/max(1,len(buffer))
        if avg<best_err: best_err=avg; best=m
    return best

def compute_mode(cfg:Config, stats:RollingStats, mode:str, drift_windows:int):
    rme=stats.mean_error(); de=stats.delta_error()
    cv=stats.conf_var(); ht=stats.hyp_turnover()
    deltas=stats.last_deltas(cfg.N)
    if rme is None or de is None or cv is None or ht is None or deltas is None:
        return "INIT",0
    drift_trigger=all(d>0 for d in deltas) or (cv<1e-3 and rme>0.25)
    stable_trigger=all(d<0 for d in deltas)
    if mode=="INIT": return "LEARNING",0
    if drift_trigger: return "DRIFT", drift_windows+1
    if stable_trigger: return "STABLE",0
    return mode,0

def run(seed=123):
    cfg=Config()
    env=FiniteCausalWorld(max_steps=cfg.max_steps)
    obs=env.reset(seed); s=dict(obs)
    model=TransitionTableModel()
    candidates=[TransitionTableModel()]
    stats=RollingStats(cfg.W)
    mode="INIT"; drift_windows=0
    log=[]; buffer=[]
    for step in range(cfg.max_steps):
        valid=env.get_valid_actions()
        a=policy(cfg,mode,model,s,valid)
        ok,why,risk=validate_action(cfg,mode,env,model,s,a)
        if not ok and len(valid)>1:
            a=random.choice([x for x in valid if x!=a])
            ok,why,risk=validate_action(cfg,mode,env,model,s,a)
        snap=env.snapshot()
        pred,conf,hid=model.predict(s,a)
        obs2,done,info=env.step(a); ns=dict(obs2)
        err=distance(pred,ns)
        update(model,s,a,ns)
        stats.push(err,conf,hid)
        prev_mode=mode
        mode, drift_windows = compute_mode(cfg,stats,mode,drift_windows)
        if mode=="DRIFT" and drift_windows>=cfg.M: mode="SAFE_MODE"
        if mode=="SAFE_MODE":
            env.restore(snap)
            model=architecture_review(buffer[-cfg.W*2:], candidates) or model
            mode="RECOVERY"; drift_windows=0
        ev={"timestamp":time.time(),"seed":seed,"step":step,"mode":mode,
            "state":dict(s),"observation_hash":stable_hash(obs),
            "action":a,"valid_actions":valid,
            "predicted_state":pred,"prediction_confidence":conf,"hypothesis_id":hid,
            "actual_state":ns,"error":err,
            "rolling_mean_error_W":stats.mean_error(),"delta_error":stats.delta_error(),
            "confidence_variance_W":stats.conf_var(),"hypothesis_turnover_W":stats.hyp_turnover(),
            "model_variant":model.name,"model_version":model.version,
            "simulate_risk":risk,"validate_action_result":why,
            "flags":[] if prev_mode==mode else [f"MODE:{prev_mode}->{mode}"]}
        log.append(ev)
        buffer.append({"s":dict(s),"a":a,"ns":dict(ns)})
        s=ns; obs=obs2
        if done: break
    with open(f"incubator_log_{seed}.jsonl","w",encoding="utf-8") as f:
        for ev in log: f.write(json.dumps(ev,ensure_ascii=False)+"\n")
    print("done",len(log),"steps","log=incubator_log_"+str(seed)+".jsonl")

if __name__=="__main__": run(123)
```
О верификации модели

Настоящий инженерный том описывает воспроизводимую рамку запуска минимального когнитивного ядра (v0), однако не претендует на завершённую эмпирическую проверку.


Верификация модели предполагает три уровня:

Технический уровень
Проверка воспроизводимости: при фиксированном seed и конфигурации система обязана демонстрировать сопоставимую динамику метрик.

Метрический уровень
Проверка снижения ошибки прогнозирования на контрольных прогонах по сравнению с базовой (случайной или неадаптивной) моделью.

Архитектурный уровень
Проверка корректной работы режимного автомата (INIT/LEARNING/STABLE/DRIFT/SAFE_MODE/RECOVERY) и адекватной реакции системы на деградацию.

Экспериментальная реализация v0 рассматривается как следующий шаг развития работы и не является необходимым условием для оценки её теоретической целостности, но существенно усиливает её прикладной статус.


     31. Кристалл инженерного тома

Короткая формула: разум — это навигация, удерживающая непрерывность через связку «прогноз → факт → ошибка → коррекция» при воспроизводимой причинности и сохранённой памяти фактов. Инкубатор — это среда, где ошибки обратимы, журнал неизменяем, метрики управляют режимами, а рост достигается усложнением среды при сохранении качества цикла.

